{"meta":{"title":"Free loop~","subtitle":"Fight for NOI2018","description":null,"author":"CNYALI","url":"http://cnyali.cn"},"pages":[{"title":"tags","date":"2018-04-11T07:39:09.000Z","updated":"2018-04-11T08:23:35.790Z","comments":true,"path":"tags/index.html","permalink":"http://cnyali.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DINIC-ditch","slug":"DINIC-ditch","date":"2018-05-30T12:25:20.000Z","updated":"2018-05-30T12:33:06.209Z","comments":true,"path":"2018/05/30/DINIC-ditch/","link":"","permalink":"http://cnyali.cn/2018/05/30/DINIC-ditch/","excerpt":"洛谷P2740 草地排水 DINIC+01矩阵网络流裸题，用01矩阵存的DINIC+当前弧优化的简单写法","text":"洛谷P2740 草地排水 DINIC+01矩阵网络流裸题，用01矩阵存的DINIC+当前弧优化的简单写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long LL;using namespace std;int n,m;#define inf 100000000#define MAXM 2000#define MAXN 205int a[MAXN][MAXN];int vis[MAXN];int cur[MAXN];queue&lt;int&gt;q;int bfs()&#123; memset(vis,-1,sizeof(vis)); vis[1]=0; q.push(1); while(!q.empty())&#123; int now=q.front(); q.pop(); for(int i=1;i&lt;=n;i++)&#123; if(vis[i]&lt;0 &amp;&amp; a[now][i])&#123; vis[i]=vis[now]+1; q.push(i); &#125; &#125; &#125; if(vis[n]&lt;0) return 0; return 1;&#125;int dfs(int u,int w)&#123; if(u==n) return w; int ans=0; for(int&amp; i=cur[u];i&lt;=n;i++)&#123; if(vis[i]==vis[u]+1&amp;&amp;a[u][i])&#123; int b=dfs(i,min(w-ans,a[u][i])); a[u][i]-=b; a[i][u]+=b; ans+=b; &#125; &#125; return ans;&#125;int main()&#123; int t; scanf(\"%d%d\",&amp;m,&amp;n); int i,j; for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); a[u][v]+=w; &#125; int ans=0; while(bfs())&#123; for (int i=1;i&lt;=n;i++) cur[i]=1; ans+=dfs(1,inf); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://cnyali.cn/categories/算法/"},{"name":"图论","slug":"算法/图论","permalink":"http://cnyali.cn/categories/算法/图论/"},{"name":"网络流","slug":"算法/图论/网络流","permalink":"http://cnyali.cn/categories/算法/图论/网络流/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://cnyali.cn/tags/网络流/"},{"name":"DINIC","slug":"DINIC","permalink":"http://cnyali.cn/tags/DINIC/"}]},{"title":"DINIC","slug":"DINIC","date":"2018-05-30T11:48:40.000Z","updated":"2018-05-30T12:01:35.985Z","comments":true,"path":"2018/05/30/DINIC/","link":"","permalink":"http://cnyali.cn/2018/05/30/DINIC/","excerpt":"网络流之DINIC 算法 ~ HDU3459举例Dinic算法引入了一个叫做分层图的概念。具体就是对于每一个点，我们根据从源点开始的bfs序列，为每一个点分配一个深度，然后我们进行若干遍dfs寻找增广路，每一次由u推出v必须保证v的深度必须是u的深度+1。下面给出代码","text":"网络流之DINIC 算法 ~ HDU3459举例Dinic算法引入了一个叫做分层图的概念。具体就是对于每一个点，我们根据从源点开始的bfs序列，为每一个点分配一个深度，然后我们进行若干遍dfs寻找增广路，每一次由u推出v必须保证v的深度必须是u的深度+1。下面给出代码 一些变量的定义1234567int s,t;//源点和汇点int cnt;//边的数量，从0开始编号。int Head[maxN];//每一个点最后一条边的编号int Next[maxM];//指向对应点的前一条边int V[maxM];//每一条边指向的点int W[maxM];//每一条边的残量int Depth[maxN];//分层图中标记深度 DINIC 主过程12345678910int Dinic()&#123; int Ans=0;//记录最大流量 while (bfs()) &#123; while (int d=dfs(s,inf)) Ans+=d; &#125; return Ans;&#125; BFS分层图过程123456789101112131415161718192021222324bool bfs()&#123; queue&lt;int&gt; Q;//定义一个bfs寻找分层图时的队列 while (!Q.empty()) Q.pop(); memset(Depth,0,sizeof(Depth)); Depth[s]=1;//源点深度为1 Q.push(s); do &#123; int u=Q.front(); Q.pop(); for (int i=Head[u];i!=-1;i=Next[i]) if ((W[i]&gt;0)&amp;&amp;(Depth[V[i]]==0))//若该残量不为0，且V[i]还未分配深度，则给其分配深度并放入队列 &#123; Depth[V[i]]=Depth[u]+1; Q.push(V[i]); &#125; &#125; while (!Q.empty()); if (Depth[t]==0)//当汇点的深度不存在时，说明不存在分层图，同时也说明不存在增广路 return 0; return 1;&#125; dfs寻找增广路过程12345678910111213141516171819int dfs(int u,int dist)//u是当前节点，dist是当前流量&#123; if (u==t)//当已经到达汇点，直接返回 return dist; for (int i=Head[u];i!=-1;i=Next[i]) &#123; if ((Depth[V[i]]==Depth[u]+1)&amp;&amp;(W[i]!=0))//注意这里要满足分层图和残量不为0两个条件 &#123; int di=dfs(V[i],min(dist,W[i]));//向下增广 if (di&gt;0)//若增广成功 &#123; W[i]-=di;//正向边减 W[i^1]+=di;反向边加 return di;//向上传递 &#125; &#125; &#125; return 0;//否则说明没有增广路，返回0&#125; DINIC 算法的优化Dinic算法还有优化，这个优化被称为当前弧优化，即每一次dfs增广时不从第一条边开始，而是用一个数组cur记录点u之前循环到了哪一条边，以此来加速 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//HDU 3459 举例代码#include&lt;bits/stdc++.h&gt;typedef long long LL;using namespace std;int n,m;#define inf 100000000#define MAXM 5000#define MAXN 50struct edg&#123;int w,to,next;&#125;x[MAXM+10];int head[MAXN],cnt;int vis[MAXN];int cur[MAXN];/////////当前弧加速void add(int u,int v,int w)&#123; x[cnt].next=head[u]; x[cnt].to=v; x[cnt].w=w; head[u]=cnt++; x[cnt].next=head[v]; x[cnt].to=u; x[cnt].w=0; head[v]=cnt++;&#125;queue&lt;int&gt;q1;int bfs()&#123; memset(vis,-1,sizeof(vis)); vis[1]=0; q1.push(1); while(!q1.empty())&#123; int now=q1.front(); q1.pop(); int j; for(j=head[now];j!=-1;j=x[j].next)&#123; if(vis[x[j].to]&lt;0&amp;&amp;x[j].w)&#123; vis[x[j].to]=vis[now]+1; q1.push(x[j].to); &#125; &#125; &#125; if(vis[n]&lt;0) return 0; return 1;&#125;int dfs(int u,int w)&#123; if(u==n) return w; int j; int ans=0; //for(j=head[u];j!=-1&amp;&amp;ans&lt;=w;j=x[j].next)&#123; //for(int&amp; j=cur[u];j!=-1&amp;&amp;ans&lt;=w;j=x[j].next)&#123;/////当前狐加速//注意这里的&amp;符号，这样i增加的同时也能改变cur[u]的值，达到记录当前弧的目的 for(j=cur[u];j!=-1&amp;&amp;ans&lt;=w;j=x[j].next)&#123; cur[u]=j; if(vis[x[j].to]==vis[u]+1&amp;&amp;x[j].w)&#123; int b=dfs(x[j].to,min(w-ans,x[j].w)); //流进去的有2个限制 min(总流量减去已经流掉的，可以流进去的) x[j].w-=b; x[j^1].w+=b; //cnt=0 开始 反向边下标=j^1 可以自己试试 ans+=b; &#125; &#125; return ans;&#125;/* j^1 举例0 1 2 3 4 50 1 10 11 100 1011 1 01 01 001 0011 0 11 10 101 100 */int main()&#123; int t,ca; scanf(\"%d\",&amp;t); ca=1; while(t--)&#123; scanf(\"%d%d\",&amp;n,&amp;m); cnt=0; memset(head,-1,sizeof(head)); int i,j; for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; int ans=0; while(bfs())&#123; for (int i=1;i&lt;=n;i++)/////当前狐加速///每一次建立完分层图后都要把cur置为每一个点的第一条边 cur[i]=head[i];/////当前狐加速 ans+=dfs(1,inf); &#125; printf(\"Case %d: %d\\n\",ca++,ans); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://cnyali.cn/categories/算法/"},{"name":"图论","slug":"算法/图论","permalink":"http://cnyali.cn/categories/算法/图论/"},{"name":"网络流","slug":"算法/图论/网络流","permalink":"http://cnyali.cn/categories/算法/图论/网络流/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://cnyali.cn/tags/网络流/"},{"name":"DINIC","slug":"DINIC","permalink":"http://cnyali.cn/tags/DINIC/"}]},{"title":"HDU2191 dp","slug":"HDU2191-dp","date":"2018-05-03T09:01:56.000Z","updated":"2018-05-03T09:12:08.201Z","comments":true,"path":"2018/05/03/HDU2191-dp/","link":"","permalink":"http://cnyali.cn/2018/05/03/HDU2191-dp/","excerpt":"HDU2191悼念512汶川大地震遇难同胞题目大意123一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。 请问：你用有限的资金最多能采购多少公斤粮食呢？ [以下题解转自网上]","text":"HDU2191悼念512汶川大地震遇难同胞题目大意123一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。 请问：你用有限的资金最多能采购多少公斤粮食呢？ [以下题解转自网上] 题解11234567891011121314151617181920212223242526272829303132333435//多重背包转换成01背包来做#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int W,n;int w[2005],v[2005];int dp[20005];int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--) &#123; memset(dp,0,sizeof(dp)); scanf(\"%d%d\",&amp;W,&amp;n); int cnt=0; int a,b,c; for(int i=0;i&lt;n;i++) &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); while(c--) &#123; w[cnt]=a; v[cnt]=b; cnt++; &#125; &#125; for(int i=0;i&lt;cnt;i++) for(int j=W;j&gt;=w[i];j--) dp[j]=max(dp[j],dp[j-w[i]]+v[i]); printf(\"%d\\n\",dp[W]); &#125; return 0;&#125; 题解2123456789101112131415161718192021222324252627282930313233//未优化的多重背包 我们定义 dp[i+1][j] 表示前i中物品（包括i）中重量不超过j的所能得到的最大价值。则状态转移方程为 dp[i+1][j]=max(dp[i][j-w[i]*k])+v[k] k=(0...g[i]);g[i]表示物品i共有几个。#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int W,n;int w[105],v[105],g[105];int dp[205][20005];int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--) &#123; memset(dp,0,sizeof(dp)); scanf(\"%d%d\",&amp;W,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(\"%d%d%d\",&amp;w[i],&amp;v[i],&amp;g[i]); &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=W;j++) &#123; dp[i+1][j]=dp[i][j]; for(int k=1;k&lt;=g[i];k++) if(j&gt;=k*w[i]) dp[i+1][j]=max(dp[i+1][j],dp[i][j-w[i]*k]+v[i]*k); &#125; printf(\"%d\\n\",dp[n][W]); &#125; return 0;&#125; 题解3123456789101112131415161718192021222324252627282930313233343536373839404142//记忆化搜索#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=105;int n,W;int w[MAXN],v[MAXN],b[MAXN];int dp[MAXN][MAXN];int dfs(int dep,int wei)&#123; if(dp[dep][wei]!=-1) return dp[dep][wei]; if(dep==n) &#123; return dp[dep][wei]=0; &#125; int res=0; for(int k=0;k&lt;=b[dep]&amp;&amp;wei&gt;=k*w[dep];k++) &#123; res=max(res,dfs(dep+1,wei-w[dep]*k)+v[dep]*k); &#125; return dp[dep][wei]=res;&#125;int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--) &#123; memset(dp,-1,sizeof(dp)); scanf(\"%d%d\",&amp;W,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(\"%d%d%d\",&amp;w[i],&amp;v[i],&amp;b[i]); &#125; printf(\"%d\\n\",dfs(0,W)); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://cnyali.cn/categories/算法/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://cnyali.cn/categories/算法/动态规划/"},{"name":"背包问题","slug":"算法/动态规划/背包问题","permalink":"http://cnyali.cn/categories/算法/动态规划/背包问题/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://cnyali.cn/tags/DP/"},{"name":"动态规划","slug":"动态规划","permalink":"http://cnyali.cn/tags/动态规划/"},{"name":"DP优化","slug":"DP优化","permalink":"http://cnyali.cn/tags/DP优化/"}]},{"title":"LUOGU 1736 DP","slug":"LUOGU-1736-DP","date":"2018-05-03T08:05:00.000Z","updated":"2018-05-03T09:07:14.186Z","comments":true,"path":"2018/05/03/LUOGU-1736-DP/","link":"","permalink":"http://cnyali.cn/2018/05/03/LUOGU-1736-DP/","excerpt":"LUOGU 1736 创意吃鱼法题目大意1在一个N*M的01矩阵中找一个最大的正方形符合对角线都是1，其它都是0。n,m&lt;=2500","text":"LUOGU 1736 创意吃鱼法题目大意1在一个N*M的01矩阵中找一个最大的正方形符合对角线都是1，其它都是0。n,m&lt;=2500 试题分析1234567891011本题暴力枚举只能过小部分的点，正解如下，转自网上，正解中用到了矩形DP中常用的预处理优化这道题其实和P1387 最大正方形很像，只不过多了一个预处理罢了s1[i][j]表示（i，j）最多向左（或右）延伸多少个格子，使这些格子中的数都是0（不包括（i，j））s2[i][j]表示（i，j）最多向上延伸多少个格子，使这些格子中的数都是0（不包括（i，j））f[i][j]表以（i，j）为右下（左下）角的最大对角线长度方程：f[i][j]=min(f[i-1][j-1],min(s1[i][j-1],s2[i-1][j]))+1;不懂可以根据这个例子想想1 0 0 0 1 0 0 0 1 dp两遍，分别对应两条对角线 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;typedef long long ll;using namespace std;int n,m,ans;int a[2509][2509],f[2509][2509],s1[2509][2509],s2[2509][2509];//s1为横向，s2为纵向 int main()&#123; cin&gt;&gt;n&gt;&gt;m; //第一遍左上——右下 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; scanf(\"%d\",&amp;a[i][j]); if(!a[i][j]) &#123; s1[i][j]=s1[i][j-1]+1; s2[i][j]=s2[i-1][j]+1; &#125; if(a[i][j]) f[i][j]=min(f[i-1][j-1],min(s1[i][j-1],s2[i-1][j]))+1; ans=max(ans,f[i][j]); &#125; //第二遍右上——左下 memset(f,0,sizeof(f)); memset(s1,0,sizeof(s1));//数组置0 memset(s2,0,sizeof(s2)); for(int i=1;i&lt;=n;i++) for(int j=m;j&gt;=1;j--) &#123; if(!a[i][j]) &#123; s1[i][j]=s1[i][j+1]+1; s2[i][j]=s2[i-1][j]+1; &#125; if(a[i][j]) f[i][j]=min(f[i-1][j+1],min(s1[i][j+1],s2[i-1][j]))+1; ans=max(ans,f[i][j]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://cnyali.cn/categories/算法/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://cnyali.cn/categories/算法/动态规划/"},{"name":"矩形动态规划","slug":"算法/动态规划/矩形动态规划","permalink":"http://cnyali.cn/categories/算法/动态规划/矩形动态规划/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://cnyali.cn/tags/DP/"},{"name":"动态规划","slug":"动态规划","permalink":"http://cnyali.cn/tags/动态规划/"},{"name":"DP优化","slug":"DP优化","permalink":"http://cnyali.cn/tags/DP优化/"}]},{"title":"test","slug":"test","date":"2018-04-11T08:37:56.000Z","updated":"2018-05-03T08:08:19.808Z","comments":true,"path":"2018/04/11/test/","link":"","permalink":"http://cnyali.cn/2018/04/11/test/","excerpt":"A+B 问题问题描述输入 A,B两个值，求和","text":"A+B 问题问题描述输入 A,B两个值，求和 输入格式两个数：A,B 输出格式一个数，即A+B 题解我不会……","categories":[{"name":"教程","slug":"教程","permalink":"http://cnyali.cn/categories/教程/"},{"name":"C++语言","slug":"教程/C-语言","permalink":"http://cnyali.cn/categories/教程/C-语言/"}],"tags":[{"name":"C++入门","slug":"C-入门","permalink":"http://cnyali.cn/tags/C-入门/"}]},{"title":"Ubuntu 16.04-hexo-github-typora","slug":"Ubuntu 16.04-hexo-github-typora","date":"2018-04-11T04:03:48.000Z","updated":"2018-04-11T08:26:25.011Z","comments":true,"path":"2018/04/11/Ubuntu 16.04-hexo-github-typora/","link":"","permalink":"http://cnyali.cn/2018/04/11/Ubuntu 16.04-hexo-github-typora/","excerpt":"Ubuntu 16.04 安装 hexo,git,typora首先安装noejs，Ubuntu源中的nodejs时旧版本，所以需要在安装后更新nodejs;123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm 更换成淘宝的镜像，否则非常慢1sudo npm config set registry https://registry.npm.taobao.org","text":"Ubuntu 16.04 安装 hexo,git,typora首先安装noejs，Ubuntu源中的nodejs时旧版本，所以需要在安装后更新nodejs;123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm 更换成淘宝的镜像，否则非常慢1sudo npm config set registry https://registry.npm.taobao.org 可以通过 sudo npm config list 查看是否生效安装更新版本的工具N1sudo npm install n -g 更新版本1sudo n stable 可以看到有 installed：版号，说明更新成功安装 hexo1sudo npm install -g hexo 安装 git1sudo apt-get install git 解决安装中进程被锁死的问题12sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock 安装 hexo 与 git 关联1sudo npm install hexo-deployer-git --save git 关联 github12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail@XX.com&quot; 生成 SSH 密钥1ssh-keygen -t rsa -C &quot;youremail@XX.com&quot; 测试密钥与github 连接1ssh -T git@github.com 新建博文1hexo new &quot;title&quot; 修改 _config.yml1sudo gedit _config.yml 编译并发布博文1hexo d -g 最后还需要在github仓库里的seting 设置 domain才能访问在你的github_name.github.io 创建自定义域名12//你要绑定的域名cnyali.cn hexo 安装主题1git clone https://github.com/litten/hexo-theme-yilia.git themes/hexo-theme-yilia hexo 启用主题修改博客目录D:\\hexo_config.yml中的theme属性，将其设置为hexo/hexo-theme-yilia1theme:hexo/hexo-theme-yilia 新建标签页面1hexo new page tags 一起奇怪的命令12345678910//initgit initgit remote add origin git@git.coding.net:6666/666.git//upgit add .git commit -m &quot;$%^&amp;$&quot;git push origin master//downgit pull origin master//git clone git@git.coding.net:6666/666.git","categories":[{"name":"教程","slug":"教程","permalink":"http://cnyali.cn/categories/教程/"},{"name":"其它","slug":"教程/其它","permalink":"http://cnyali.cn/categories/教程/其它/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://cnyali.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://cnyali.cn/tags/github/"},{"name":"typora","slug":"typora","permalink":"http://cnyali.cn/tags/typora/"}]}]}